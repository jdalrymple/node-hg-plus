(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('babylon'), require('magic-string'), require('babel-types'), require('util'), require('shebang-regex'), require('babel-traverse'), require('path'), require('fs'), require('mkdirp')) :
  typeof define === 'function' && define.amd ? define(['exports', 'babylon', 'magic-string', 'babel-types', 'util', 'shebang-regex', 'babel-traverse', 'path', 'fs', 'mkdirp'], factory) :
  (factory((global.esnext = global.esnext || {}),global.babylon,global.MagicString,global.t,global.util,global.shebangRegex,global.traverse,global.path,global.fs,global.mkdirp));
}(this, function (exports,babylon,MagicString,t,util,shebangRegex,traverse,path,fs,mkdirp) { 'use strict';

  MagicString = 'default' in MagicString ? MagicString['default'] : MagicString;
  shebangRegex = 'default' in shebangRegex ? shebangRegex['default'] : shebangRegex;
  traverse = 'default' in traverse ? traverse['default'] : traverse;
  mkdirp = 'default' in mkdirp ? mkdirp['default'] : mkdirp;

  function clone(object) {
    return JSON.parse(JSON.stringify(object));
  }

  var BABEL_PARSE_OPTIONS = {
    sourceType: 'module',
    strictMode: true,
    allowImportExportEverywhere: false, // consistent with espree
    allowReturnOutsideFunction: true,
    allowSuperOutsideMethod: true,
    plugins: ['flow', 'jsx', 'asyncFunctions', 'asyncGenerators', 'classConstructorCall', 'classProperties', 'decorators', 'doExpressions', 'exponentiationOperator', 'exportExtensions', 'functionBind', 'functionSent', 'objectRestSpread', 'trailingFunctionCommas']
  };

  Object.defineProperty(babylon.tokTypes.backQuote, 'updateContext', {
    value: babylon.tokTypes.backQuote.updateContext,
    configurable: false
  });

  function parse$1 (source) {
    return babylon.parse(source, BABEL_PARSE_OPTIONS);
  }

  var asyncGenerator = function () {
    function AwaitValue(value) {
      this.value = value;
    }

    function AsyncGenerator(gen) {
      var front, back;

      function send(key, arg) {
        return new Promise(function (resolve, reject) {
          var request = {
            key: key,
            arg: arg,
            resolve: resolve,
            reject: reject,
            next: null
          };

          if (back) {
            back = back.next = request;
          } else {
            front = back = request;
            resume(key, arg);
          }
        });
      }

      function resume(key, arg) {
        try {
          var result = gen[key](arg);
          var value = result.value;

          if (value instanceof AwaitValue) {
            Promise.resolve(value.value).then(function (arg) {
              resume("next", arg);
            }, function (arg) {
              resume("throw", arg);
            });
          } else {
            settle(result.done ? "return" : "normal", result.value);
          }
        } catch (err) {
          settle("throw", err);
        }
      }

      function settle(type, value) {
        switch (type) {
          case "return":
            front.resolve({
              value: value,
              done: true
            });
            break;

          case "throw":
            front.reject(value);
            break;

          default:
            front.resolve({
              value: value,
              done: false
            });
            break;
        }

        front = front.next;

        if (front) {
          resume(front.key, front.arg);
        } else {
          back = null;
        }
      }

      this._invoke = send;

      if (typeof gen.return !== "function") {
        this.return = undefined;
      }
    }

    if (typeof Symbol === "function" && Symbol.asyncIterator) {
      AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
        return this;
      };
    }

    AsyncGenerator.prototype.next = function (arg) {
      return this._invoke("next", arg);
    };

    AsyncGenerator.prototype.throw = function (arg) {
      return this._invoke("throw", arg);
    };

    AsyncGenerator.prototype.return = function (arg) {
      return this._invoke("return", arg);
    };

    return {
      wrap: function (fn) {
        return function () {
          return new AsyncGenerator(fn.apply(this, arguments));
        };
      },
      await: function (value) {
        return new AwaitValue(value);
      }
    };
  }();

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var Module = function () {
    function Module(id, source) {
      classCallCheck(this, Module);
      this.metadata = {};
      this.warnings = [];

      this.id = id;
      this.reinit(source);
    }

    /**
     * @private
     */


    createClass(Module, [{
      key: 'reinit',
      value: function reinit(source) {
        this.source = source;
        this.ast = parse$1(source);
        this.tokens = this.ast.tokens;
        this.magicString = new MagicString(source, {
          filename: this.id
        });
      }
    }, {
      key: 'commit',
      value: function commit() {
        var source = this.magicString.toString();

        if (source !== this.source) {
          this.reinit(source);
        }
      }
    }, {
      key: 'warn',
      value: function warn(node, type, message) {
        this.warnings.push({ node: clone(node), type: type, message: message });
      }
    }, {
      key: 'tokensForNode',
      value: function tokensForNode(node) {
        return this.tokensInRange(node.start, node.end);
      }
    }, {
      key: 'tokensInRange',
      value: function tokensInRange(start, end) {
        var tokenRange = this.tokenIndexRangeForSourceRange(start, end);

        if (!tokenRange) {
          return [];
        }

        return this.tokens.slice(tokenRange.start, tokenRange.end);
      }
    }, {
      key: 'tokenIndexRangeForSourceRange',
      value: function tokenIndexRangeForSourceRange(start, end) {
        var location = null;
        var length = 0;
        var tokens = this.tokens;

        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (token.end > end) {
            break;
          } else if (token.start >= start) {
            if (location === null) {
              location = i;
            }
            length++;
          }
        }

        if (location === null) {
          return null;
        }

        return { start: location, end: location + length };
      }
    }, {
      key: 'render',
      value: function render() {
        return {
          code: this.magicString.toString(),
          ast: this.ast,
          warnings: this.warnings.slice(),
          metadata: this.metadata
        };
      }
    }, {
      key: 'sourceOf',
      value: function sourceOf(node) {
        return this.source.slice(node.start, node.end);
      }
    }]);
    return Module;
  }();

  function cleanNode(node) {
    if (!t.isNode(node)) {
      throw new Error('node must be a valid node type, got: ' + util.inspect(node));
    }

    var result = Object.create(null);
    var fields = t.NODE_FIELDS[node.type];

    result.type = node.type;

    Object.keys(fields).forEach(function (field) {
      if (field in node) {
        var value = node[field];

        if (t.isNode(value)) {
          result[field] = cleanNode(value);
        } else if (Array.isArray(value)) {
          result[field] = value.map(function (element) {
            return t.isNode(element) ? cleanNode(element) : element;
          });
        } else {
          result[field] = value;
        }
      } else {
        result[field] = fields[field].default;
      }
    });

    return result;
  }

  function replace(destination, source) {
    for (var key in destination) {
      delete destination[key];
    }

    for (var _key in source) {
      destination[_key] = source[_key];
    }

    return destination;
  }

  function hasParens(path, module) {
    var tokens = module.tokens;

    var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(path.node.start, path.node.end),
        start = _module$tokenIndexRan.start,
        end = _module$tokenIndexRan.end;

    var tokenBefore = tokens[start - 1];
    var tokenAfter = tokens[end];

    return tokenBefore.type.label === '(' && tokenAfter.type.label === ')';
  }

  function needsParens(path) {
    var node = path.node,
        parent = path.parent;


    if (t.isArrowFunctionExpression(node)) {
      if (t.isMemberExpression(parent)) {
        return parent.object === node;
      } else if (t.isCallExpression(parent)) {
        return parent.callee === node;
      } else if (t.isBinaryExpression(parent)) {
        return true;
      } else if (t.isLogicalExpression(parent)) {
        return true;
      }
    }

    return false;
  }

  function indexOfElementMatchingPredicate(list, predicate) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var index = start;
    while (index < list.length) {
      var _element = list[index];
      if (predicate(_element)) {
        return index;
      }
      index++;
    }
    return ~index;
  }

  function findToken(label, tokens) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    return findTokenMatchingPredicate(function (token) {
      return token.type.label === label;
    }, tokens, start);
  }

  function findTokenMatchingPredicate(predicate, tokens) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var index = indexOfElementMatchingPredicate(tokens, predicate, start);
    if (index < 0) {
      var loc = tokens[start].loc.start;
      throw new Error('unexpected token after ' + loc.line + ':' + (loc.column + 1));
    }
    return { index: index, token: tokens[index] };
  }

  function findEndBraceTokenBalanced(tokens) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    // We count '{' and '${' as left tokens because string interpolations start
    // with '${' and end with the same '}' as objects and blocks.
    return findEndTokenBalanced(['{', '${'], '}', tokens, start);
  }

  function findEndParenthesisTokenBalanced(tokens) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    return findEndTokenBalanced('(', ')', tokens, start);
  }

  function findEndTokenBalanced(left, right, tokens) {
    var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var index = indexOfBalancedToken(tokens, tokenMatcher(left), tokenMatcher(right), start);
    if (index < 0) {
      var loc = tokens[start].loc.start;
      throw new Error('expected balanced tokens starting at ' + loc.line + ':' + (loc.column + 1));
    }
    return { index: index, token: tokens[index] };
  }

  function tokenMatcher(label) {
    if (typeof label === 'string') {
      return function (token) {
        return token.type.label === label;
      };
    } else {
      return function (token) {
        return label.indexOf(token.type.label) >= 0;
      };
    }
  }

  function indexOfBalancedToken(tokens, leftPredicate, rightPredicate) {
    var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    var depth = 0;
    return indexOfElementMatchingPredicate(tokens, function (token) {
      if (leftPredicate(token)) {
        depth++;
      }
      if (rightPredicate(token)) {
        depth--;
      }
      return depth === 0;
    }, start);
  }

  var name = 'functions.arrow';
  var description = 'Transform regular functions to arrow functions as appropriate.';

  function visitor(module) {
    var editor = module.magicString;
    var functions = metadata(module).functions;

    return {
      FunctionExpression: function FunctionExpression(path) {
        var node = path.node,
            parent = path.parent;

        // Skip generator functions.

        if (node.generator) {
          return;
        }

        // Only process anonymous functions.
        if (node.id) {
          return;
        }

        // Skip object literal methods.
        if (t.isProperty(parent) && parent.method) {
          return;
        }

        // Skip class methods.
        if (t.isClassMethod(parent) && parent.value === node) {
          return;
        }

        // Only process functions with a single return statement.
        if (node.body.body.length !== 1) {
          return;
        }

        var _node$body$body = slicedToArray(node.body.body, 1),
            statement = _node$body$body[0];

        if (!t.isReturnStatement(statement) || !statement.argument) {
          return;
        }

        // Skip functions referencing `this` or `arguments`.
        if (referencesThisOrArguments(path)) {
          return;
        }

        rewriteBlocklessArrowFunction(path, module, functions);

        // Remove extra parentheses if they're no longer needed.
        if (t.isExpressionStatement(parent) && hasParens(path, module)) {
          var _module$tokenIndexRan = module.tokenIndexRangeForSourceRange(node.start, node.end),
              start = _module$tokenIndexRan.start,
              end = _module$tokenIndexRan.end;

          var tokens = module.tokens;

          var lparen = tokens[start - 1];
          var rparen = tokens[end];
          editor.remove(lparen.start, node.start);
          editor.remove(node.end, rparen.end);
        }
      },


      /**
       * Look for functions that are manually bound, e.g.
       *
       *   this.onclick = (function() {
       *     console.log('registering');
       *     this.register();
       *   }).bind(this);
       */
      CallExpression: function CallExpression(path) {
        var node = path.node,
            callee = path.node.callee;


        if (!t.isMemberExpression(callee)) {
          return;
        }

        var object = callee.object,
            property = callee.property;


        if (!t.isFunctionExpression(object) || object.id) {
          return;
        }

        if (!t.isIdentifier(property) || property.name !== 'bind') {
          return;
        }

        if (node.arguments.length !== 1 || !t.isThisExpression(node.arguments[0])) {
          return;
        }

        var objectPath = path.get('callee').get('object');

        if (referencesArguments(objectPath)) {
          return;
        }

        if (objectPath.node.generator) {
          return;
        }

        rewriteBlockArrowFunction(objectPath, module, functions);

        // `() => {}.bind(this)` -> `() => {}bind(this)`
        //          ^

        var _module$tokenIndexRan2 = module.tokenIndexRangeForSourceRange(object.end, property.start),
            start = _module$tokenIndexRan2.start,
            end = _module$tokenIndexRan2.end;

        var tokens = module.tokens;

        for (var i = start; i < end; i++) {
          var token = tokens[i];
          if (token.type.label === '.') {
            editor.remove(token.start, token.end);
          }
        }

        // `() => {}bind(this)` -> `() => {}`
        //          ^^^^^^^^^^
        editor.remove(property.start, node.end);

        replace(node, object);
      }
    };
  }

  function referencesThisOrArguments(path) {
    var result = false;

    path.scope.traverse(path.node, {
      Function: function Function(fnPath) {
        // Skip nested functions.
        fnPath.skip();
      },
      ThisExpression: function ThisExpression(thisPath) {
        result = true;
        thisPath.stop();
      },
      Identifier: function Identifier(identPath) {
        if (identPath.node.name === 'arguments') {
          result = true;
          identPath.stop();
        }
      }
    });

    return result;
  }

  function referencesArguments(path) {
    var result = false;

    path.scope.traverse(path.node, {
      Function: function Function(fnPath) {
        // Skip nested functions.
        fnPath.skip();
      },
      Identifier: function Identifier(identPath) {
        if (identPath.node.name === 'arguments') {
          result = true;
          identPath.stop();
        }
      }
    });

    return result;
  }

  function metadata(module) {
    if (!module.metadata[name]) {
      module.metadata[name] = { functions: [] };
    }
    return module.metadata[name];
  }

  function rewriteBlocklessArrowFunction(path, module, functions) {
    var node = path.node;

    var _node$body$body2 = slicedToArray(node.body.body, 1),
        statement = _node$body$body2[0];

    functions.push(cleanNode(node));

    var _getFunctionPunctuati = getFunctionPunctuation(node, module),
        fn = _getFunctionPunctuati.fn,
        paramsStart = _getFunctionPunctuati.paramsStart,
        paramsEnd = _getFunctionPunctuati.paramsEnd,
        blockStart = _getFunctionPunctuati.blockStart,
        blockEnd = _getFunctionPunctuati.blockEnd;

    var paramsNeedParens = node.params.length !== 1 || !t.isIdentifier(node.params[0]);

    var editor = module.magicString;
    if (!paramsNeedParens) {
      // `(a)` -> `a`
      //  ^ ^
      editor.remove(paramsStart.start, paramsStart.end);
      editor.remove(paramsEnd.start, paramsEnd.end);
    }

    // `function() {` -> `() =>`
    editor.remove(fn.start, paramsStart.start);
    editor.overwrite(blockStart.start, blockStart.end, '=>');

    var contentBetweenBlockStartBraceAndReturn = module.source.slice(blockStart.end, statement.start);
    var contentOfReturnArgument = module.sourceOf(statement.argument);

    var shouldCollapseToOneLine =
    // Wouldn't remove anything interesting.
    /^\s*$/.test(contentBetweenBlockStartBraceAndReturn) &&
    // Returned value isn't multi-line.
    /^[^\n\r]*$/.test(contentOfReturnArgument);

    if (shouldCollapseToOneLine) {
      // Removes whitespace between `{` and `return` and `foo;` and `}`.
      //
      //  function() {
      //    return foo;
      //  }
      //
      if (blockStart.end === statement.start) {
        editor.insertLeft(statement.start, ' ');
      } else {
        editor.overwrite(blockStart.end, statement.start, ' ');
      }
      editor.remove(statement.end, blockEnd.end);
    }

    var returnArgumentNeedsParens = t.isSequenceExpression(statement.argument);

    // `return foo;` -> `foo`
    //  ^^^^^^^   ^
    editor.overwrite(statement.start, statement.argument.start, returnArgumentNeedsParens ? '(' : '');
    if (statement.argument.end === statement.end) {
      editor.insertLeft(statement.end, returnArgumentNeedsParens ? ')' : '');
    } else {
      editor.overwrite(statement.argument.end, statement.end, returnArgumentNeedsParens ? ')' : '');
    }

    // `…}` -> `…`
    editor.remove(blockEnd.start, blockEnd.end);

    node.type = 'ArrowFunctionExpression';
    node.body = statement.argument;
    node.expression = true;

    if (needsParens(path) && !hasParens(path, module)) {
      editor.insertRight(node.start, '(');
      editor.insertLeft(node.end, ')');
    }

    if (bodyNeedsParens(node.body)) {
      editor.insertRight(node.body.start, '(');
      editor.insertLeft(node.body.end, ')');
    }
  }

  /**
   * Rewrites a function expression to an arrow function, preserving the block.
   */
  function rewriteBlockArrowFunction(path, module, functions) {
    var node = path.node;


    functions.push(cleanNode(node));

    var _getFunctionPunctuati2 = getFunctionPunctuation(node, module),
        fn = _getFunctionPunctuati2.fn,
        paramsStart = _getFunctionPunctuati2.paramsStart,
        paramsEnd = _getFunctionPunctuati2.paramsEnd,
        blockStart = _getFunctionPunctuati2.blockStart;

    var paramsNeedsParens = node.params.length !== 1 || !t.isIdentifier(node.params[0]);
    var editor = module.magicString;

    if (!paramsNeedsParens) {
      // `(a)` -> `a`
      //  ^ ^
      editor.remove(paramsStart.start, paramsStart.end);
      editor.remove(paramsEnd.start, paramsEnd.end);
    }

    // `function() {` -> `() =>`
    //  ^^^^^^^^   ^         ^^
    editor.remove(fn.start, paramsStart.start);
    editor.insertLeft(blockStart.start, '=> ');

    node.type = 'ArrowFunctionExpression';
  }

  /**
   * Get the tokens for the relevant function punctuation, i.e.
   *
   *            paramsStart    paramsEnd
   *             fn       |    |
   *              |       |    |
   *              v       v    v
   *   let add = (function(a, b) { <- blockStart
   *     return a + b;
   *   });
   *   ^
   *   |
   *   blockEnd
   */
  function getFunctionPunctuation(node, module) {
    var tokens = module.tokensForNode(node);

    var _findToken = findToken('function', tokens, 0),
        functionTokenIndex = _findToken.index,
        fn = _findToken.token;

    var _findToken2 = findToken('(', tokens, functionTokenIndex),
        paramsStartIndex = _findToken2.index,
        paramsStart = _findToken2.token;

    var _findEndParenthesisTo = findEndParenthesisTokenBalanced(tokens, paramsStartIndex),
        paramsEndIndex = _findEndParenthesisTo.index,
        paramsEnd = _findEndParenthesisTo.token;

    var _findToken3 = findToken('{', tokens, paramsEndIndex),
        blockStartIndex = _findToken3.index,
        blockStart = _findToken3.token;

    var _findEndBraceTokenBal = findEndBraceTokenBalanced(tokens, blockStartIndex),
        blockEnd = _findEndBraceTokenBal.token;

    return {
      fn: fn,
      paramsStart: paramsStart,
      paramsEnd: paramsEnd,
      blockStart: blockStart,
      blockEnd: blockEnd
    };
  }

  function bodyNeedsParens(body) {
    return t.isObjectExpression(body) || t.isAssignmentExpression(body) && t.isObjectPattern(body.left);
  }



  var functionsArrow = Object.freeze({
    name: name,
    description: description,
    visitor: visitor
  });

  // FIXME: This is only capable of unindenting one level.
  function unindent(magicString) {
    var original = magicString.original;

    var indentString = magicString.getIndentString();

    var atStartOfLine = true;
    for (var i = 0; i < original.length; i++) {
      if (original[i] === '\n' || original[i] === '\r') {
        atStartOfLine = true;
      } else if (atStartOfLine) {
        atStartOfLine = false;
        if (original.slice(i, i + indentString.length) === indentString) {
          magicString.remove(i, i + indentString.length);
        }
      }
    }
  }

  /**
   * Represents a module binding for either an import or export statement.
   */
  var Binding = function () {
    function Binding(localName, exportName) {
      classCallCheck(this, Binding);

      this.localName = localName;
      this.exportName = exportName;
    }

    createClass(Binding, [{
      key: 'isAliased',
      value: function isAliased() {
        return this.localName !== this.exportName;
      }
    }, {
      key: 'isDefaultExport',
      value: function isDefaultExport() {
        return this.exportName === 'default';
      }
    }]);
    return Binding;
  }();

  /**
   * Builds an export specifier list string for use in an export statement.
   */
  var ExportSpecifierListStringBuilder = function () {
    function ExportSpecifierListStringBuilder(bindings) {
      classCallCheck(this, ExportSpecifierListStringBuilder);

      this.bindings = bindings;
    }

    createClass(ExportSpecifierListStringBuilder, [{
      key: 'toString',
      value: function toString() {
        return '{ ' + this.bindings.map(function (binding) {
          if (!binding.isAliased()) {
            return binding.localName;
          } else {
            return binding.localName + ' as ' + binding.exportName;
          }
        }).join(', ') + ' }';
      }
    }], [{
      key: 'build',
      value: function build(bindings) {
        return new ExportSpecifierListStringBuilder(bindings).toString();
      }
    }]);
    return ExportSpecifierListStringBuilder;
  }();

  /**
   * Builds an import specifier list string for use in an import statement.
   */
  var ImportSpecifierListStringBuilder = function () {
    function ImportSpecifierListStringBuilder(bindings) {
      classCallCheck(this, ImportSpecifierListStringBuilder);

      this.bindings = bindings;
    }

    createClass(ImportSpecifierListStringBuilder, [{
      key: 'toString',
      value: function toString() {
        var defaultBinding = void 0;
        var namedBindings = [];

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.bindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var binding = _step.value;

            if (binding.isDefaultExport()) {
              defaultBinding = binding;
            } else {
              namedBindings.push(binding);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var result = '';

        var hasNamedBindings = namedBindings.length > 0;
        if (defaultBinding) {
          result += defaultBinding.localName;
          if (hasNamedBindings) {
            result += ', ';
          }
        }

        if (hasNamedBindings) {
          result += '{ ' + namedBindings.map(function (binding) {
            if (!binding.isAliased()) {
              return binding.localName;
            } else {
              return binding.exportName + ' as ' + binding.localName;
            }
          }).join(', ') + ' }';
        }

        return result;
      }
    }], [{
      key: 'build',
      value: function build(bindings) {
        return new ImportSpecifierListStringBuilder(bindings).toString();
      }
    }]);
    return ImportSpecifierListStringBuilder;
  }();

  function claim(scope) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ref';

    if (isUsedName(scope, name)) {
      var suffix = 1;
      var prefix = name;
      do {
        name = prefix + '$' + suffix++;
      } while (isUsedName(scope, name));
    }

    var program = scope.getProgramParent();
    program.references[name] = true;
    program.uids[name] = true;
    return t.identifier(name);
  }

  function isDeclaredName(scope, name) {
    return scope.hasBinding(name);
  }

  function isUsedName(scope, name) {
    return scope.hasBinding(name) || scope.hasGlobal(name)
    // FIXME: Do we want this?
    // scope.hasReference(name)
    ;
  }

  var name$1 = 'modules.commonjs';
  var description$1 = 'Transform CommonJS modules into ES6 modules.';

  function visitor$1(module) {
    metadata$1(module);

    return {
      Program: function Program(path) {
        unwrapIIFE(path, module);
        removeUseStrictDirective(path, module);
        rewriteImportsAndExports(path, module);
      },
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        // TODO: Warn about `require`, `module`, and `exports` global references.
        var node = path.node;


        if (node.name === 'require' && !path.scope.hasBinding('require')) {
          var source = extractRequirePathNode(path.parent);

          if (source) {
            module.warn(path.parent, 'unsupported-import', 'Unsupported \'require\' call cannot be transformed into an import');
          }
        } else if (node.name === 'exports') {
          module.warn(node, 'unsupported-export', 'Unsupported export cannot be turned into an \'export\' statement');
        }
      }
    };
  }

  /**
   * Unwrap an IIFE at program scope if that's the only thing that's there.
   *
   *   (function() {
   *     // All program body here.
   *   })();
   */
  function unwrapIIFE(path, module) {
    var node = path.node;

    var iife = extractModuleIIFE(node);

    if (!iife) {
      return;
    }

    var _node$body = slicedToArray(node.body, 1),
        statement = _node$body[0];

    var body = iife.body.body;


    node.body = body;
    metadata$1(module).unwrapped = cleanNode(iife);

    var tokens = module.tokensForNode(iife);
    var iifeHeaderEnd = body[0].start;

    var _findToken = findToken('{', tokens),
        iifeBlockStartIndex = _findToken.index,
        iifeBlockStart = _findToken.token;

    for (var p = iifeBlockStart.end; p < iifeHeaderEnd; p++) {
      if (module.source.charAt(p) === '\n') {
        iifeHeaderEnd = p + 1;
        break;
      }
    }

    var iifeFooterStart = body[body.length - 1].end;

    var _findEndTokenBalanced = findEndTokenBalanced('{', '}', tokens, iifeBlockStartIndex),
        iifeBlockEnd = _findEndTokenBalanced.token;

    for (var _p = iifeBlockEnd.start; _p > iifeFooterStart; _p--) {
      if (module.source.charAt(_p) === '\n') {
        if (module.source.charAt(_p) === '\r') {
          _p--;
        }
        iifeFooterStart = _p;
        break;
      }
    }

    // `(function() {\n  foo();\n})();` -> `foo();`
    //  ^^^^^^^^^^^^^^^^^      ^^^^^^^
    module.magicString.remove(statement.start, iifeHeaderEnd);
    module.magicString.remove(iifeFooterStart, statement.end);
    unindent(module.magicString);
  }

  /**
   * Remove a 'use strict' directive in `path`'s body.
   */
  function removeUseStrictDirective(path, module) {
    var directives = path.node.directives;

    for (var i = 0; i < directives.length; i++) {
      var directive = directives[i];

      if (directive.value.value === 'use strict') {
        var start = directive.start,
            end = directive.end;

        // Eat any trailing newlines.

        while (module.source.charAt(end) === '\n') {
          end++;
        }

        module.magicString.remove(start, end);
        directives.splice(i, 1);
        metadata$1(module).directives.push(cleanNode(directive));
      }
    }
  }

  /**
   * Re-write requires as imports/exports and exports sets as export statements.
   */
  function rewriteImportsAndExports(path, module) {
    var body = path.get('body');

    if (!Array.isArray(body)) {
      throw new Error('expected body paths from program node, got: ' + body);
    }

    body.forEach(function (statement) {
      return rewriteAsExport(statement, module) || rewriteAsImport(statement, module);
    });
  }

  function rewriteAsExport(path, module) {
    var node = path.node;


    if (!t.isExpressionStatement(node)) {
      return false;
    }

    var expression = node.expression;


    if (!t.isAssignmentExpression(expression)) {
      return false;
    }

    var left = expression.left,
        right = expression.right;


    if (isExportsObject(path.get('expression.left'))) {
      return rewriteSingleExportAsDefaultExport(path, module);
    } else if (t.isMemberExpression(left) && !left.computed) {
      if (!isExportsObject(path.get('expression.left.object'))) {
        return false;
      }

      if (t.isFunctionExpression(right)) {
        return rewriteNamedFunctionExpressionExport(path, module);
      } else if (t.isIdentifier(right)) {
        return rewriteNamedIdentifierExport(path, module);
      } else {
        return rewriteNamedValueExport(path, module);
      }
    } else {
      return false;
    }
  }

  function isExportsObject(path) {
    var node = path.node;


    if (t.isMemberExpression(node)) {
      return !path.scope.hasBinding('module') && t.isIdentifier(node.object, { name: 'module' }) && t.isIdentifier(node.property, { name: 'exports' });
    } else if (t.isIdentifier(node, { name: 'exports' })) {
      return !path.scope.hasBinding('exports');
    } else {
      return t.isThisExpression(node);
    }
  }

  function isSimpleObjectExpression(node) {
    if (!t.isObjectExpression(node)) {
      return false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = node.properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var property = _step.value;

        if (!t.isObjectProperty(property) || !t.isIdentifier(property.key) || !t.isIdentifier(property.value)) {
          return false;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }

  function rewriteSingleExportAsDefaultExport(path, module) {
    var node = path.node,
        right = path.node.expression.right;


    if (isSimpleObjectExpression(right)) {
      var _bindings = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = right.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = _step2.value,
              key = _step2$value.key,
              value = _step2$value.value;

          _bindings.push(new Binding(value.name, key.name));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      metadata$1(module).exports.push({
        type: 'named-export',
        bindings: _bindings,
        node: cleanNode(node)
      });

      module.magicString.overwrite(node.start, node.end, 'export ' + ExportSpecifierListStringBuilder.build(_bindings) + ';');

      path.replaceWith(t.exportNamedDeclaration(null, _bindings.map(function (binding) {
        return t.exportSpecifier(t.identifier(binding.localName), t.identifier(binding.exportName));
      }), null));
    } else {
      var _pathNode = extractRequirePathNode(right);

      if (_pathNode) {
        module.magicString.overwrite(node.expression.start, node.expression.end, 'export * from ' + module.source.slice(_pathNode.start, _pathNode.end));

        metadata$1(module).exports.push({
          type: 'namespace-export',
          bindings: [],
          node: cleanNode(node)
        });

        path.replaceWith(t.exportAllDeclaration(_pathNode));
      } else {
        metadata$1(module).exports.push({ type: 'default-export', node: cleanNode(node) });
        module.magicString.overwrite(node.start, right.start, 'export default ');
        path.replaceWith(t.exportDefaultDeclaration(right));
      }
    }

    return true;
  }

  function rewriteNamedFunctionExpressionExport(path, module) {
    var node = path.node,
        _path$node$expression = path.node.expression,
        exportName = _path$node$expression.left.property.name,
        right = _path$node$expression.right,
        id = _path$node$expression.right.id;


    var fnBinding = id ? id.name : null;
    var localId = claim(path.scope, fnBinding || exportName);
    var localName = localId.name;

    metadata$1(module).exports.push({
      type: 'named-export',
      bindings: [{
        exportName: exportName,
        localName: localName
      }],
      node: cleanNode(node)
    });

    var isFunctionDeclaration = true;

    if (localName === exportName) {
      // `exports.foo = function foo() {}` → `export function foo() {}`
      //  ^^^^^^^^^^^^^^                      ^^^^^^^
      module.magicString.overwrite(node.start, right.start, 'export ');

      if (!id) {
        module.magicString.insertLeft(right.start + 'function'.length, ' ' + localName);
        right.id = t.identifier(exportName);
      }

      right.type = 'FunctionDeclaration';
      right.expression = false;
      right.id = t.identifier(exportName);
      delete right.start;
      delete right.end;

      path.replaceWith(t.exportNamedDeclaration(right, [], null));
    } else {
      var declaration = right;

      if (!id) {
        module.magicString.remove(node.start, right.start);
        module.magicString.insertLeft(right.start + 'function'.length, ' ' + localName);
        right.type = 'FunctionDeclaration';
        right.id = localId;
      } else if (fnBinding === localName) {
        right.type = 'FunctionDeclaration';
        module.magicString.remove(node.start, right.start);
      } else {
        isFunctionDeclaration = false;
        module.magicString.overwrite(node.start, right.start, 'let ' + localName + ' = ');
        declaration = t.variableDeclaration('let', [t.variableDeclarator(localId, right)]);
      }

      module.magicString.insertRight(node.end, '\nexport { ' + localName + ' as ' + exportName + ' };');

      path.replaceWithMultiple([declaration, t.exportNamedDeclaration(null, [t.exportSpecifier(localId, t.identifier(exportName))])]);
    }

    if (isFunctionDeclaration) {
      var lastCharacterPosition = node.end - 1;

      if (module.source.charAt(lastCharacterPosition) === ';') {
        module.magicString.remove(lastCharacterPosition, node.end);
      }
    }
  }

  function rewriteNamedIdentifierExport(path, module) {
    var node = path.node,
        _path$node$expression2 = path.node.expression,
        property = _path$node$expression2.left.property,
        right = _path$node$expression2.right;


    var replacements = void 0;
    var localBinding = void 0;

    if (isDeclaredName(path.scope, right.name)) {
      localBinding = right.name;

      if (right.name === property.name) {
        module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' };');
      } else {
        module.magicString.overwrite(node.start, node.end, 'export { ' + right.name + ' as ' + property.name + ' };');
      }

      replacements = [t.exportNamedDeclaration(null, [t.exportSpecifier(right, property)], null)];
    } else {
      localBinding = claim(path.scope, property.name).name;

      if (localBinding === property.name) {
        module.magicString.overwrite(node.start, right.start, 'export let ' + localBinding + ' = ');
        replacements = [t.exportNamedDeclaration(t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), [], null)];
      } else {
        module.magicString.overwrite(node.start, right.start, 'let ' + localBinding + ' = ');
        module.magicString.insertRight(node.end, '\nexport { ' + localBinding + ' as ' + property.name + ' };');
        replacements = [t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), t.exportNamedDeclaration(null, [t.exportSpecifier(t.identifier(localBinding), property)], null)];
      }
    }

    metadata$1(module).exports.push({
      type: 'named-export',
      bindings: [{
        exportName: property.name,
        localName: localBinding
      }],
      node: cleanNode(node)
    });

    path.replaceWithMultiple(replacements);

    return true;
  }

  function rewriteNamedValueExport(path, module) {
    var node = path.node,
        _path$node$expression3 = path.node.expression,
        property = _path$node$expression3.left.property,
        right = _path$node$expression3.right;

    var localBinding = claim(path.scope, property.name).name;

    metadata$1(module).exports.push({
      type: 'named-export',
      bindings: [{
        exportName: property.name,
        localName: localBinding
      }],
      node: cleanNode(node)
    });

    if (localBinding === property.name) {
      // `exports.foo = 99;` → `export let foo = 99;`
      //  ^^^^^^^^              ^^^^^^^^^^^
      module.magicString.overwrite(node.start, property.start, 'export let ');

      path.replaceWith(t.exportNamedDeclaration(t.variableDeclaration('let', [t.variableDeclarator(t.identifier(property.name), right)]), [], null));
    } else {
      // `exports.foo = 99;` → `let foo$1 = 99;`
      //  ^^^^^^^^^^^^^^        ^^^^^^^^^^^^
      module.magicString.overwrite(node.start, right.start, 'let ' + localBinding + ' = ');

      var nodeIndex = path.parent.body.indexOf(node);

      if (nodeIndex < 0) {
        throw new Error('could not locate ' + node.type + ' at ' + node.line + ':' + node.column + ' in its parent block');
      }

      var nextStatement = path.parent.body[nodeIndex + 1];

      // `export { foo$1 as foo };`
      var exportStatement = 'export { ' + localBinding + ' as ' + property.name + ' };';

      if (nextStatement) {
        // Insert before the next statement…
        module.magicString.insertRight(nextStatement.start, exportStatement + '\n');
      } else {
        // …or after the last one of the program.
        module.magicString.insertLeft(node.end, '\n' + exportStatement);
      }

      path.replaceWithMultiple([t.variableDeclaration('let', [t.variableDeclarator(t.identifier(localBinding), right)]), t.exportNamedDeclaration(null, [t.exportSpecifier(t.identifier(localBinding), t.identifier(property.name))], null)]);
    }

    return true;
  }

  function rewriteAsImport(path, module) {
    if (isDeclaredName(path.scope, 'require')) {
      return false;
    }

    return rewriteSingleExportRequire(path, module) || rewriteNamedExportRequire(path, module) || rewriteDeconstructedImportRequire(path, module) || rewriteSideEffectRequire(path, module);
  }

  function rewriteSingleExportRequire(path, module) {
    var node = path.node;


    if (!t.isVariableDeclaration(node)) {
      return false;
    }

    var declarations = node.declarations;

    var extractableDeclarations = [];

    declarations.forEach(function (declaration) {
      var id = declaration.id,
          init = declaration.init;


      if (!t.isIdentifier(id)) {
        return;
      }

      var pathNode = extractRequirePathNode(init);

      if (!pathNode) {
        return;
      }

      extractableDeclarations.push({
        declaration: declaration, id: id, pathNode: pathNode
      });
    });

    if (declarations.length === 0) {
      return false;
    }

    if (declarations.length !== extractableDeclarations.length) {
      // TODO: We have to replace only part of it.
      return false;
    }

    rewriteRequireAsImports('default-import', path, module, extractableDeclarations.map(function (_ref) {
      var id = _ref.id,
          pathNode = _ref.pathNode;
      return {
        bindings: [new Binding(id.name, 'default')],
        pathNode: pathNode
      };
    }));

    path.replaceWithMultiple(extractableDeclarations.map(function (_ref2) {
      var id = _ref2.id,
          pathNode = _ref2.pathNode;
      return t.importDeclaration([t.importDefaultSpecifier(id)], pathNode);
    }));

    return true;
  }

  function rewriteNamedExportRequire(path, module) {
    var declaration = extractSingleDeclaration(path.node);

    if (!declaration) {
      return false;
    }

    var id = declaration.id,
        init = declaration.init;


    if (!t.isIdentifier(id) || !init || !t.isMemberExpression(init) || init.computed) {
      return false;
    }

    var pathNode = extractRequirePathNode(init.object);

    if (!pathNode) {
      return false;
    }

    rewriteRequireAsImport('named-import', path, module, [new Binding(id.name, init.property.name)], pathNode);

    path.replaceWith(t.importDeclaration([t.importSpecifier(id, init.property)], pathNode));

    return true;
  }

  function rewriteDeconstructedImportRequire(path, module) {
    var declaration = extractSingleDeclaration(path.node);

    if (!declaration) {
      return false;
    }

    var id = declaration.id,
        init = declaration.init;


    if (!t.isObjectPattern(id)) {
      return false;
    }

    var bindings = [];

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = id.properties[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var _step3$value = _step3.value,
            key = _step3$value.key,
            value = _step3$value.value;

        if (!t.isIdentifier(value)) {
          return false;
        }
        bindings.push(new Binding(value.name, key.name));
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var pathNode = extractRequirePathNode(init);

    if (!pathNode) {
      return false;
    }

    rewriteRequireAsImport('named-import', path, module, bindings, pathNode);

    path.replaceWith(t.importDeclaration(bindings.map(function (binding) {
      return t.importSpecifier(t.identifier(binding.localName), t.identifier(binding.exportName));
    }), pathNode));

    return true;
  }

  function rewriteSideEffectRequire(path, module) {
    var node = path.node;


    if (!t.isExpressionStatement(node)) {
      return false;
    }

    var pathNode = extractRequirePathNode(node.expression);

    if (!pathNode) {
      return false;
    }

    rewriteRequireAsImport('bare-import', path, module, [], pathNode);

    path.replaceWith(t.importDeclaration([], pathNode));

    return true;
  }

  function rewriteRequireAsImport(type, path, module, bindings, pathNode) {
    rewriteRequireAsImports(type, path, module, [{ bindings: bindings, pathNode: pathNode }]);
  }

  function rewriteRequireAsImports(type, path, module, imports) {
    var node = path.node;

    var importStatements = [];

    imports.forEach(function (_ref3) {
      var bindings = _ref3.bindings,
          pathNode = _ref3.pathNode;

      metadata$1(module).imports.push({
        type: type,
        node: cleanNode(node),
        bindings: bindings,
        path: pathNode.value
      });

      var pathString = module.source.slice(pathNode.start, pathNode.end);

      if (bindings.length === 0) {
        importStatements.push('import ' + pathString + ';');
      } else {
        importStatements.push('import ' + ImportSpecifierListStringBuilder.build(bindings) + ' from ' + pathString + ';');
      }
    });

    module.magicString.overwrite(node.start, node.end, importStatements.join('\n'));
  }

  function metadata$1(module) {
    if (!module.metadata[name$1]) {
      module.metadata[name$1] = {
        imports: [],
        exports: [],
        directives: []
      };
    }
    return module.metadata[name$1];
  }

  function extractSingleDeclaration(node) {
    if (!t.isVariableDeclaration(node)) {
      return null;
    }

    if (node.declarations.length !== 1) {
      return null;
    }

    return node.declarations[0];
  }

  function extractRequirePathNode(node) {
    if (!node || !t.isCallExpression(node)) {
      return null;
    }

    if (!t.isIdentifier(node.callee, { name: 'require' })) {
      return null;
    }

    if (node.arguments.length !== 1) {
      return null;
    }

    var arg = node.arguments[0];

    if (!t.isStringLiteral(arg)) {
      return null;
    }

    return arg;
  }

  /**
   * @private
   */
  function extractModuleIIFE(node) {
    if (!t.isProgram(node)) {
      return null;
    }

    if (node.body.length !== 1) {
      return null;
    }

    var _node$body2 = slicedToArray(node.body, 1),
        statement = _node$body2[0];

    if (!t.isExpressionStatement(statement)) {
      return null;
    }

    var call = statement.expression;


    if (t.isUnaryExpression(call) && call.operator === 'void') {
      // e.g. `void function(){}();`
      call = call.argument;
    }

    if (!t.isCallExpression(call)) {
      return null;
    }

    var _call = call,
        callee = _call.callee,
        args = _call.arguments;


    var iife = void 0;

    if (t.isFunctionExpression(callee)) {
      // e.g. `(function() {})();`
      if (args.length !== 0) {
        return null;
      }

      iife = callee;
    } else if (t.isMemberExpression(callee)) {
      // e.g. `(function() {}).call(this);`
      var object = callee.object,
          property = callee.property,
          computed = callee.computed;


      if (computed || !t.isFunctionExpression(object)) {
        return null;
      }

      if (!t.isIdentifier(property, { name: 'call' })) {
        return null;
      }

      if (args.length !== 1 || !t.isThisExpression(args[0])) {
        return null;
      }

      iife = object;
    } else {
      return null;
    }

    if (iife.id || iife.params.length > 0 || iife.generator) {
      return null;
    }

    return iife;
  }



  var modulesCommonjs = Object.freeze({
    name: name$1,
    description: description$1,
    visitor: visitor$1
  });

  /**
   * Determines the most restrictive declaration kind for a variable declaration.
   * `const` is preferred, followed by `let` if one or more bindings are
   * reassigned, then `var` if block scoping cannot be used.
   */
  function mostRestrictiveKindForDeclaration(path) {
    var ids = path.getBindingIdentifiers();
    var scope = path.scope;

    var isConst = path.node.declarations.every(function (declaration) {
      return declaration.init;
    });

    for (var id in ids) {
      var binding = scope.getBinding(id);

      // Does this binding disqualify block scoping for this declaration entirely?
      if (!bindingCouldBeBlockScope(binding)) {
        return 'var';
      }

      // Is this binding reassigned?
      if (isConst && !binding.constant) {
        isConst = false;
      }
    }

    return isConst ? 'const' : 'let';
  }

  /**
   * Does this binding meet the requirements for block scoping?
   */
  function bindingCouldBeBlockScope(binding) {
    // Are there duplicate declarations?
    if (binding.constantViolations.some(function (path) {
      return t.isVariableDeclarator(path.node);
    })) {
      return false;
    }

    var definition = binding.path;
    var definitionBlockParent = findBlockParent(definition);

    return binding.referencePaths.every(function (reference) {
      return (
        // Does this reference come after the definition?
        reference.node.start > definition.node.start &&
        // Does this reference share the same block parent?
        hasAncestor(reference, definitionBlockParent)
      );
    });
  }

  /**
   * Find the closest ancestor that creates a block scope.
   */
  function findBlockParent(path) {
    var parent = path;

    while (!t.isBlockParent(parent.node)) {
      parent = parent.parentPath;
    }

    return parent;
  }

  /**
   * Determines whether `ancestor` is an ancestor of `path`.
   *
   * TODO: Use getEarliestCommonAncestorFrom?
   */
  function hasAncestor(path, ancestor) {
    if (path === ancestor) {
      return true;
    } else if (path.parentPath) {
      return hasAncestor(path.parentPath, ancestor);
    } else {
      return false;
    }
  }

  var name$2 = 'declarations.block-scope';
  var description$2 = 'Transform `var` into `let` and `const` as appropriate.';

  function visitor$2(module) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _metadata = metadata$2(module),
        declarations = _metadata.declarations;

    return {
      VariableDeclaration: function VariableDeclaration(path) {
        var node = path.node;


        if (node.kind !== 'var') {
          return;
        }

        var kind = mostRestrictiveKindForDeclaration(path);

        if (kind !== 'var') {
          if (kind === 'const' && !constAllowed(path, options)) {
            kind = 'let';
          }
          module.magicString.overwrite(node.start, node.start + 'var'.length, kind);
          declarations.push(cleanNode(node));
          node.kind = kind;
        } else {
          module.warn(node, 'unsupported-declaration', '\'var\' declaration cannot be converted to block scope');
        }
      }
    };
  }

  /**
   * Delegates to user-supplied options to determine whether `let` is allowed.
   */
  function constAllowed(path, options) {
    var disableConst = options.disableConst;

    if (typeof disableConst === 'function') {
      return !disableConst(path);
    } else {
      return !disableConst;
    }
  }

  function metadata$2(module) {
    if (!module.metadata[name$2]) {
      module.metadata[name$2] = { declarations: [] };
    }
    return module.metadata[name$2];
  }

var declarationsBlockScope = Object.freeze({
    name: name$2,
    description: description$2,
    visitor: visitor$2
  });

  var name$3 = 'objects.destructuring';
  var description$3 = 'Transform some declarations and assignments to the more compact destructuring form.';

  function visitor$3(module) {
    var meta = metadata$3(module);

    return {
      VariableDeclaration: function VariableDeclaration(path) {
        var node = path.node;


        for (var index = 0; index < node.declarations.length; index++) {
          var elements = extractSequentialDestructurableElements(module, node.declarations, index);
          rewriteDestructurableElements(module, elements);

          if (elements.length !== 0) {
            // Add information about the transformation.
            meta.push({
              ids: elements.map(function (_ref) {
                var id = _ref.id;
                return cleanNode(id);
              }),
              inits: elements.map(function (_ref2) {
                var init = _ref2.init;
                return cleanNode(init);
              })
            });

            // Mutate the AST to reflect the new reality.
            node.declarations.splice(index, elements.length, t.variableDeclarator(t.objectPattern(elements.map(function (declarator) {
              return t.objectProperty(declarator.id, declarator.id, false, true);
            })), elements[0].init.object));
          }
        }
      },
      AssignmentExpression: function AssignmentExpression(path) {
        if (!t.isExpressionStatement(path.parent)) {
          return;
        }

        var node = path.node;

        var assignments = extractSequentialDestructurableElements(module, [node]);

        if (assignments.length === 0) {
          return;
        }

        // `a = obj.a;` -> `(a = obj.a);`
        //                  ^         ^
        module.magicString.insertLeft(assignments[0].start, '(');
        module.magicString.insertRight(assignments[assignments.length - 1].end, ')');

        rewriteDestructurableElements(module, assignments);

        // Add information about the transformation.
        meta.push({
          ids: assignments.map(function (assignment) {
            return cleanNode(assignment.left);
          }),
          inits: assignments.map(function (assignment) {
            return cleanNode(assignment.right);
          })
        });

        path.replaceWith(t.assignmentExpression('=', t.objectPattern(assignments.map(function (assignment) {
          return t.objectProperty(t.identifier(assignment.left.name), t.identifier(assignment.left.name), false, true);
        })), node.right.object));
      },
      SequenceExpression: function SequenceExpression(path) {
        var expressions = path.node.expressions;


        for (var index = 0; index < expressions.length; index++) {
          var assignments = extractSequentialDestructurableElements(module, expressions, index);

          if (assignments.length > 0 && index === 0) {
            // `a = obj.a;` -> `(a = obj.a);`
            module.magicString.insertLeft(assignments[0].start, '(');
            module.magicString.insertRight(assignments[assignments.length - 1].end, ')');
          }

          if (assignments.length > 0) {
            rewriteDestructurableElements(module, assignments);

            meta.push({
              ids: assignments.map(function (assignment) {
                return cleanNode(assignment.left);
              }),
              inits: assignments.map(function (assignment) {
                return cleanNode(assignment.right);
              })
            });

            expressions.splice(index, assignments.length, t.assignmentExpression('=', t.objectPattern(assignments.map(function (_ref3) {
              var left = _ref3.left;
              return t.objectProperty(left, left, false, true);
            })), assignments[0].right.object));
          }
        }

        if (expressions.length === 1) {
          path.replaceWith(expressions[0]);
        }
      }
    };
  }

  function extractSequentialDestructurableElements(module, elements) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    var result = [];
    var objectSource = null;

    for (var i = start; i < elements.length; i++) {
      var element = elements[i];

      var _ref4 = leftRightOfAssignment(element) || {},
          _left = _ref4.left,
          _right = _ref4.right;

      if (!t.isIdentifier(_left)) {
        break;
      }

      if (!t.isMemberExpression(_right)) {
        break;
      }

      if (_right.computed) {
        break;
      }

      if (_left.name !== _right.property.name) {
        break;
      }

      var thisObjectSource = module.sourceOf(_right.object);

      if (!objectSource) {
        objectSource = thisObjectSource;
      } else if (objectSource !== thisObjectSource) {
        break;
      }

      result.push(element);

      if (!isSafeToConsolidate(_right.object)) {
        break;
      }
    }

    return result;
  }

  function rewriteDestructurableElements(module, elements) {
    if (elements.length === 0) {
      return;
    }

    var firstElement = elements[0];

    // `const a = obj.a, b = obj.b;` -> `const { a = obj.a, b = obj.b;`
    //                                         ^^
    module.magicString.insertLeft(leftRightOfAssignment(firstElement).left.start, '{ ');

    for (var i = 0; i < elements.length - 1; i++) {
      var _leftRightOfAssignmen = leftRightOfAssignment(elements[i]),
          _left2 = _leftRightOfAssignmen.left,
          _right2 = _leftRightOfAssignmen.right;
      // `const { a = obj.a, b = obj.b;` -> `const { a, b = obj.b;`
      //           ^^^^^^^^


      module.magicString.remove(_left2.end, _right2.end);
    }

    var lastElement = elements[elements.length - 1];

    var _leftRightOfAssignmen2 = leftRightOfAssignment(lastElement),
        lastLeft = _leftRightOfAssignmen2.left,
        lastRight = _leftRightOfAssignmen2.right;

    // `const { a, b = obj.b;` -> `const { a, b } = obj.b;`
    //                                         ^^


    module.magicString.insertRight(lastLeft.end, ' }');

    // `const { a, b } = obj.b;` -> `const { a, b } = obj;`
    //                      ^^
    module.magicString.remove(lastRight.object.end, lastRight.end);
  }

  function metadata$3(module) {
    if (!module.metadata[name$3]) {
      module.metadata[name$3] = [];
    }
    return module.metadata[name$3];
  }

  function leftRightOfAssignment(node) {
    if (t.isVariableDeclarator(node)) {
      return { left: node.id, right: node.init };
    } else if (t.isAssignmentExpression(node) && node.operator === '=') {
      return { left: node.left, right: node.right };
    } else {
      return null;
    }
  }

  function isSafeToConsolidate(node) {
    return t.isIdentifier(node);
  }

var objectsDestructuring = Object.freeze({
    name: name$3,
    description: description$3,
    visitor: visitor$3
  });

  function escape(char, start, end, charAt, insert) {
    for (var i = start; i < end; i++) {
      if (charAt(i) === char) {
        // If this character is preceded by an odd number of backslashes, then it
        // is already escaped, so we shouldn't add another backslash.
        var numPrecedingBackslashes = 0;
        while (i - numPrecedingBackslashes - 1 >= start && charAt(i - numPrecedingBackslashes - 1) === '\\') {
          numPrecedingBackslashes++;
        }
        if (numPrecedingBackslashes % 2 == 0) {
          insert(i, '\\');
        }
      }
    }
  }

  function escapeString(char, string) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : string.length;
    var magicString = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new MagicString(string);

    escape(char, start, end, function (index) {
      return string[index];
    }, function (index, string) {
      return magicString.insertRight(index, string);
    });
    return magicString.toString();
  }

  function unescape(char, start, end, charAt, remove) {
    for (var i = start; i < end; i++) {
      if (charAt(i) === '\\' && charAt(i + 1) === char) {
        remove(i, i + 1);
        i++;
      }
    }
  }

  function unescapeString(char, string) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : string.length;
    var magicString = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new MagicString(string);

    unescape(char, start, end, function (index) {
      return string[index];
    }, function (start, end) {
      return magicString.remove(start, end);
    });
    return magicString.toString();
  }

  var name$4 = 'strings.template';
  var description$4 = 'Transforms manual string concatenation into template strings.';

  function visitor$4(module) {
    var meta = metadata$4(module);

    return {
      BinaryExpression: function BinaryExpression(path) {
        var node = path.node;

        var parts = flatten(node);

        if (parts) {
          meta.concatenations.push({
            node: cleanNode(node),
            parts: parts.map(cleanNode)
          });

          path.replaceWith(combine(module, node, parts));
        }
      }
    };
  }

  function flatten(node) {
    if (!t.isBinaryExpression(node) || node.operator !== '+') {
      return null;
    }

    if (node.loc.start.line !== node.loc.end.line) {
      return null;
    }

    var left = node.left,
        right = node.right;


    if (t.isStringLiteral(left)) {
      // This is the root.
      return [left, right];
    } else {
      // We need to go deeper.
      var flattenedLeft = flatten(left);

      if (!flattenedLeft) {
        return null;
      }

      return [].concat(toConsumableArray(flattenedLeft), [right]);
    }
  }

  function combine(module, node, parts) {
    var annotatedParts = parts.map(function (part, i) {
      var previousPart = parts[i - 1];
      var nextPart = parts[i + 1];
      var annotatedPart = {
        node: part,
        prefix: '',
        suffix: ''
      };

      if (previousPart) {
        var _insignificantContent = insignificantContentSeparatedByPlus(module, previousPart, part),
            _insignificantContent2 = slicedToArray(_insignificantContent, 2),
            prefix = _insignificantContent2[1];

        annotatedPart.prefix = prefix.replace(/^\s*/, '');
      }

      if (nextPart) {
        var _insignificantContent3 = insignificantContentSeparatedByPlus(module, part, nextPart),
            _insignificantContent4 = slicedToArray(_insignificantContent3, 1),
            suffix = _insignificantContent4[0];

        annotatedPart.suffix = suffix.replace(/\s*$/, '');
      }

      return annotatedPart;
    });

    if (annotatedParts.every(function (part) {
      return t.isStringLiteral(part.node) && !part.prefix && !part.suffix;
    })) {
      return combineStrings(module, parts);
    } else {
      return buildTemplateString(module, node, annotatedParts);
    }
  }

  function combineStrings(module, parts) {
    var quote = module.source.charAt(parts[0].start);
    var value = parts[0].value;


    for (var i = 0; i < parts.length; i++) {
      var thisPart = parts[i];
      var nextPart = parts[i + 1];
      if (nextPart) {
        // Remove the space between the strings.
        module.magicString.remove(thisPart.end - 1, nextPart.start + 1);
        value += nextPart.value;
      }
      var thisPartQuote = module.source.charAt(parts[i].start);
      if (thisPartQuote !== quote) {
        unescapeString(thisPartQuote, module.source, thisPart.start + 1, thisPart.end - 1, module.magicString);
        escapeString(quote, module.source, thisPart.start + 1, thisPart.end - 1, module.magicString);
      }
    }

    var lastPart = parts[parts.length - 1];
    module.magicString.overwrite(lastPart.end - 1, lastPart.end, quote);

    return t.stringLiteral(value);
  }

  function buildTemplateString(module, node, parts) {
    var expressions = [];
    var quasis = [];

    var firstPart = parts[0];
    var firstNode = firstPart.node;
    var cooked = '';
    var raw = '';

    module.magicString.insertLeft(firstNode.start, '`');

    parts.forEach(function (_ref, i) {
      var node = _ref.node,
          prefix = _ref.prefix,
          suffix = _ref.suffix;

      if (prefix || suffix || !t.isStringLiteral(node)) {
        // This one has to be an interpolated expression.
        module.magicString.insertRight(node.start, '${' + prefix);
        module.magicString.insertLeft(node.end, suffix + '}');
        expressions.push(node);
        quasis.push(t.templateElement({ cooked: cooked, raw: escapeString('`', raw) }, false));
        cooked = '';
        raw = '';
      } else {
        // This one can become a quasi,
        cooked += node.value;
        raw += unescapeString(node.extra.raw[0], node.extra.raw.slice(1, -1));
        module.magicString.remove(node.start, node.start + 1);
        module.magicString.remove(node.end - 1, node.end);
        var thisPartQuote = module.source.charAt(node.start);
        unescapeString(thisPartQuote, module.source, node.start + 1, node.end - 1, module.magicString);
        escapeString('`', module.source, node.start, node.end, module.magicString);
      }

      var nextPart = parts[i + 1];

      if (nextPart) {
        module.magicString.remove(node.end, nextPart.node.start);
      }
    });

    quasis.push(t.templateElement({ cooked: cooked, raw: raw }, true));

    var lastPart = parts[parts.length - 1];

    if (lastPart.node.end === node.end) {
      module.magicString.insertRight(node.end, '`');
    } else {
      module.magicString.overwrite(lastPart.node.end, node.end, '`');
    }

    return t.templateLiteral(quasis, expressions);
  }

  function insignificantContentSeparatedByPlus(module, left, right) {
    var tokens = module.tokensInRange(left.end, right.start);
    var leftComments = [];
    var rightComments = [];
    var hasFoundPlusToken = false;
    var last = left;

    tokens.forEach(function (token, i) {
      var next = tokens[i + 1] || right;
      if (token.type.label === '+/-' && token.value === '+') {
        hasFoundPlusToken = true;
      } else if (token.type === 'CommentBlock') {
        var expandedSource = module.source.slice(last.end, next.start);
        (hasFoundPlusToken ? rightComments : leftComments).push(expandedSource);
      }
      last = token;
    });

    return [leftComments.join(''), rightComments.join('')];
  }

  function metadata$4(module) {
    if (!module.metadata[name$4]) {
      module.metadata[name$4] = { concatenations: [] };
    }
    return module.metadata[name$4];
  }



  var stringsTemplate = Object.freeze({
    name: name$4,
    description: description$4,
    visitor: visitor$4
  });

  var name$5 = 'objects.shorthand';
  var description$5 = 'Use shorthand notation for object properties.';

  function visitor$5(module) {
    var meta = metadata$5(module);

    return {
      ObjectProperty: function ObjectProperty(path) {
        var node = path.node;


        if (node.computed || node.shorthand) {
          return;
        }

        if (!t.isIdentifier(node.key) || !t.isIdentifier(node.value)) {
          return;
        }

        if (node.key.name !== node.value.name) {
          return;
        }

        var tokens = module.tokensForNode(node);

        var _findTokenMatchingPre = findTokenMatchingPredicate(function (token) {
          return token.start === node.key.start;
        }, tokens),
            keyTokenIndex = _findTokenMatchingPre.index,
            keyToken = _findTokenMatchingPre.token;

        var _findTokenMatchingPre2 = findTokenMatchingPredicate(function (token) {
          return token.type.label === ':';
        }, tokens, keyTokenIndex),
            colonTokenIndex = _findTokenMatchingPre2.index,
            colonToken = _findTokenMatchingPre2.token;

        var _findTokenMatchingPre3 = findTokenMatchingPredicate(function (token) {
          return token.start === node.value.start;
        }, tokens, colonTokenIndex),
            valueToken = _findTokenMatchingPre3.token;

        var sourceBetweenKeyAndColon = module.source.slice(keyToken.end, colonToken.start);
        var sourceBetweenColonAndValue = module.source.slice(colonToken.end, valueToken.start);

        // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
        //  ^^^^^^^^^^^                ^^^^^^^
        module.magicString.overwrite(keyToken.start, colonToken.end, sourceBetweenKeyAndColon.trim());

        // `a /* 1 */ : /* 2 */ a` -> `/* 1 *//* 2 */a`
        //             ^^^^^^^^^              ^^^^^^^
        if (colonToken.end !== valueToken.start) {
          module.magicString.overwrite(colonToken.end, valueToken.start, sourceBetweenColonAndValue.trim());
        }

        meta.properties.push(cleanNode(node));
        node.shorthand = true;
      }
    };
  }

  function metadata$5(module) {
    if (!module.metadata[name$5]) {
      module.metadata[name$5] = { properties: [] };
    }
    return module.metadata[name$5];
  }

var objectsShorthand = Object.freeze({
    name: name$5,
    description: description$5,
    visitor: visitor$5
  });

  var name$6 = 'objects.concise';
  var description$6 = 'Use concise object property method syntax.';

  function visitor$6(module) {
    return {
      ObjectProperty: function ObjectProperty(path) {
        var node = path.node;


        if (node.method) {
          return;
        }

        if (!t.isFunctionExpression(node.value) || node.value.id) {
          return;
        }

        var tokens = module.tokensForNode(node);
        var keyEnd = node.key.end;
        var functionEnd = void 0;

        if (node.computed) {
          var _findToken = findToken('[', tokens, 0),
              startBracketIndex = _findToken.index;

          var _findEndTokenBalanced = findEndTokenBalanced('[', ']', tokens, startBracketIndex),
              endBracketIndex = _findEndTokenBalanced.index,
              endBracket = _findEndTokenBalanced.token;

          keyEnd = endBracket.end;
          functionEnd = findToken('function', tokens, endBracketIndex).token.end;
        } else {
          functionEnd = findToken('function', tokens, 0).token.end;
        }

        module.magicString.remove(keyEnd, functionEnd);
        metadata$6(module).properties.push(cleanNode(node));

        path.replaceWith(t.objectMethod('method', node.key, node.value.params, node.value.body, node.computed));
      }
    };
  }

  function metadata$6(module) {
    if (!module.metadata[name$6]) {
      module.metadata[name$6] = {
        properties: []
      };
    }
    return module.metadata[name$6];
  }

var objectsConcise = Object.freeze({
    name: name$6,
    description: description$6,
    visitor: visitor$6
  });

  var allPlugins = [objectsShorthand, objectsConcise, modulesCommonjs, functionsArrow, declarationsBlockScope, objectsDestructuring, stringsTemplate];

  var OptionError = function (_Error) {
    inherits(OptionError, _Error);

    function OptionError(message) {
      classCallCheck(this, OptionError);

      var _this = possibleConstructorReturn(this, (OptionError.__proto__ || Object.getPrototypeOf(OptionError)).call(this, message));

      _this.message = message;
      return _this;
    }

    return OptionError;
  }(Error);

  var DelayedWritableFileStream = function () {
    function DelayedWritableFileStream(path, options) {
      classCallCheck(this, DelayedWritableFileStream);

      this.path = path;
      this.options = options;
    }

    createClass(DelayedWritableFileStream, [{
      key: 'write',
      value: function write(chunk) {
        return this.stream.write(chunk);
      }
    }, {
      key: 'end',
      value: function end() {
        return this.stream.end();
      }
    }, {
      key: 'stream',
      get: function get() {
        if (!this._stream) {
          mkdirp.sync(path.dirname(this.path));
          this._stream = fs.createWriteStream(this.path, this.options);
        }
        return this._stream;
      }
    }]);
    return DelayedWritableFileStream;
  }();

  function run(args) {
    var options = parseArguments(args);

    if (options.error) {
      process.stderr.write(options.error + '\n');
      help(process.stderr);
      process.exit(1);
    } else if (options.help) {
      help(process.stdout);
    } else {
      (function () {
        var input = options.input ? fs.createReadStream(options.input, { encoding: 'utf8' }) : process.stdin;
        var output = options.output ? new DelayedWritableFileStream(options.output, { encoding: 'utf8' }) : process.stdout;

        var plugins = allPlugins.filter(function (plugin) {
          if (options.blacklist) {
            return options.blacklist[plugin.name] !== true;
          } else if (options.whitelist) {
            return options.whitelist[plugin.name] === true;
          } else {
            return true;
          }
        });

        readStream(input).then(function (source) {
          return convert(source, { plugins: plugins, validate: options.validate, parse: options.parse });
        }).then(function (result) {
          printWarnings(input.path || '[stdin]', result.warnings);
          output.write(result.code);
        }).catch(function (error) {
          console.error(error.stack);
          process.exit(1);
        });
      })();
    }
  }

  function printWarnings(path, warnings) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = warnings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var warning = _step.value;

        printWarning(path, warning);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function printWarning(path, warning) {
    var loc = warning.node.loc;
    process.stderr.write('WARNING: ' + path + ':' + loc.start.line + ':' + (loc.start.column + 1) + '  ' + warning.type + '  ' + warning.message + '\n');
  }

  function readStream(stream) {
    return new Promise(function (resolve, reject) {
      var data = '';
      stream.setEncoding('utf8');
      stream.on('data', function (chunk) {
        return data += chunk;
      });
      stream.on('error', reject);
      stream.on('end', function () {
        return resolve(data);
      });
    });
  }

  function parseArguments(args) {
    var blacklist = null;
    var whitelist = null;
    var input = void 0;
    var output = void 0;
    var validate = void 0;
    var inline = false;
    var parse = void 0;

    for (var i = 0; i < args.length; i++) {
      switch (args[i]) {
        case '-i':
        case '--input':
          if (input) {
            return { error: 'Encountered duplicate input option: ' + args[i + 1] };
          }
          input = parsePath(args[++i]);
          break;

        case '-o':
        case '--output':
          if (output) {
            return { error: 'Encountered duplicate output option: ' + args[i + 1] };
          }
          output = parsePath(args[++i]);
          break;

        case '-h':
        case '--help':
          return { help: true };

        case '-w':
        case '--whitelist':
          if (blacklist) {
            return { error: 'Encountered whitelist after blacklist: ' + args[i + 1] };
          }
          if (!whitelist) {
            whitelist = blank();
          }
          parseList(args[++i]).forEach(function (name) {
            return whitelist[name] = true;
          });
          break;

        case '-b':
        case '--blacklist':
          if (whitelist) {
            return { error: 'Encountered blacklist after whitelist: ' + args[i + 1] };
          }
          if (!blacklist) {
            blacklist = blank();
          }
          parseList(args[++i]).forEach(function (name) {
            return blacklist[name] = true;
          });
          break;

        case '-I':
        case '--inline':
          inline = true;
          break;

        case '--validate':
        case '--no-validate':
          validate = args[i] === '--validate';
          break;

        default:
          if (args[i][0] === '-') {
            return { error: 'Unknown option: ' + args[i] };
          }
          if (input) {
            return { error: 'Duplicate input option: ' + args[i] };
          }
          input = args[i];
          break;
      }
    }

    if (inline) {
      if (!input) {
        return { error: 'Asked to replace input inline but no input was given' };
      } else if (output) {
        return { error: 'Asked to replace input inline but output is already set: ' + output };
      }
      output = input;
    }

    return { input: input, output: output, blacklist: blacklist, whitelist: whitelist, validate: validate, parse: parse };
  }

  function parseList(arg) {
    if (arg === '') {
      return [];
    } else if (!arg || arg[0] === '-') {
      throw new OptionError('Expected a list but got: ' + arg);
    }
    return arg.split(',').filter(function (item) {
      return item;
    });
  }

  function parsePath(arg) {
    if (!arg || arg[0] === '-') {
      throw new OptionError('Expected a path but got: ' + arg);
    }
    return arg;
  }

  function help(out) {
    var $0 = path.basename(process.argv[1]);
    out.write($0 + ' -o output.js input.js   # read and write files directly\n');
    out.write($0 + ' input.js > output.js    # read file and write stdout\n');
    out.write($0 + ' < input.js > output.js  # read stdin and write stdout\n');
    out.write($0 + ' -I file.js              # rewrite a file inline\n');
    out.write($0 + ' -b modules.commonjs     # blacklist plugins\n');
    out.write($0 + ' -w modules.commonjs     # whitelist plugins\n');
    out.write('\n');
    writeSectionHeader(out, 'Built-in Plugins');
    out.write('\n');
    table({ out: out, padding: 2, indent: 2 }, allPlugins.sort(function (left, right) {
      return left.name.localeCompare(right.name);
    }).map(function (_ref) {
      var name = _ref.name,
          description = _ref.description;
      return [name, description];
    }));
    out.write('\n');
    writeSectionHeader(out, 'Additional Options');
    out.write('\n');
    table({ out: out, padding: 4, indent: 2 }, [['--[no-]validate', 'Turn validation on or off (default: on).']]);
  }

  function writeSectionHeader(out, title) {
    if (out.isTTY) {
      out.write('\x1b[1m');
    }
    out.write(title + '\n');
    if (out.isTTY) {
      out.write('\x1b[0m');
    }
  }

  function table(options, data) {
    var padding = options.padding || 0;
    var indent = options.indent || 0;
    var out = options.out;
    var longest = [];

    data.forEach(function (row) {
      row.forEach(function (value, i) {
        if (!(i in longest) || value.length > longest[i]) {
          longest[i] = value.length;
        }
      });
    });

    data.forEach(function (row) {
      for (var j = indent; j--;) {
        out.write(' ');
      }
      row.forEach(function (value, i) {
        out.write(value);
        for (var _j = longest[i] + padding - value.length; _j--;) {
          out.write(' ');
        }
      });
      out.write('\n');
    });
  }

  function blank() {
    return Object.create(null);
  }

  function convert(source) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (Array.isArray(options)) {
      console.warn('convert(source, plugins) is deprecated, please call as convert(source, options)'); // eslint-disable-line no-console
      options = { plugins: options };
    }

    var _options = options,
        _options$validate = _options.validate,
        validate = _options$validate === undefined ? true : _options$validate,
        _options$plugins = _options.plugins,
        plugins = _options$plugins === undefined ? allPlugins : _options$plugins;

    var shebangMatch = source.match(shebangRegex);

    if (shebangMatch) {
      source = source.slice(shebangMatch.index + shebangMatch[0].length);
    }

    var module = new Module(null, source, parse$1(source));

    plugins.forEach(function (plugin) {
      var name = plugin.name,
          visitor = plugin.visitor;

      var pluginOptions = options[name];
      try {
        traverse(module.ast, visitor(module, pluginOptions));
        module.commit();
      } catch (e) {
        e.message = 'Error running plugin ' + name + ': ' + e.message;
        e.source = module.source;
        throw e;
      }
    });

    var result = module.render();

    if (validate) {
      var error = validateResult(result);
      if (error) {
        result.warnings.push({
          type: 'output-validation-failure',
          message: error.message,
          node: {
            loc: {
              start: error.loc
            }
          }
        });
      }
    }

    if (shebangMatch) {
      result.code = shebangMatch[0] + result.code;
    }

    return result;
  }

  function validateResult(_ref) {
    var code = _ref.code;

    try {
      parse$1(code);
      return null;
    } catch (ex) {
      return ex;
    }
  }

  exports.convert = convert;
  exports.run = run;

  Object.defineProperty(exports, '__esModule', { value: true });

}));